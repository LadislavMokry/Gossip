{
  "name": "Manual Intake - Text and File Upload",
  "nodes": [
    {
      "parameters": {
        "path": "manual-intake",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "manual-intake-webhook",
      "name": "Manual Intake Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        200,
        300
      ],
      "webhookId": "4f5d2f4d-2ad4-4a1a-9c5c-8a9dc3f5f632"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const bodyRaw = $json.body ?? $json.rawBody ?? $json;\nlet body = bodyRaw;\n\nif (typeof bodyRaw === 'string') {\n  try {\n    body = JSON.parse(bodyRaw);\n  } catch (e) {\n    body = {};\n  }\n} else if (bodyRaw && typeof bodyRaw === 'object' && typeof bodyRaw.data === 'string') {\n  try {\n    body = JSON.parse(bodyRaw.data);\n  } catch (e) {\n    body = bodyRaw;\n  }\n}\n\nconst binaryKeys = $binary ? Object.keys($binary) : [];\nconst binaryKey = binaryKeys.length ? binaryKeys[0] : '';\nconst hasFile = binaryKeys.length > 0;\n\nreturn {\n  json: {\n    mode: hasFile ? 'file' : 'text',\n    title: body.title || $json.title || '',\n    text: body.text || body.content || body.raw_text || $json.text || $json.content || $json.raw_text || '',\n    binaryKey\n  },\n  binary: $binary\n};"
      },
      "id": "detect-mode",
      "name": "Detect Input Mode",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        420,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "8f80c3d6-6b2d-4d33-8d5b-4b9f5f83d9f8",
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "leftValue": "={{ $json.mode }}",
              "rightValue": "file"
            }
          ]
        }
      },
      "id": "has-file",
      "name": "Has File?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        640,
        300
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const fs = require('fs');\nconst path = require('path');\n\nconst binaryKey = $json.binaryKey || (Object.keys($binary || {})[0] || '');\nconst binary = binaryKey ? $binary[binaryKey] : null;\nif (!binary) {\n  throw new Error('No file uploaded (binary data missing)');\n}\n\nconst fileName = binary.fileName || 'upload';\nconst ext = (path.extname(fileName) || '').replace('.', '').toLowerCase();\nconst baseName = path.basename(fileName, path.extname(fileName));\nconst safeBase = baseName\n  .replace(/[^a-zA-Z0-9-_]+/g, '-')\n  .replace(/-+/g, '-')\n  .replace(/^[-_]+|[-_]+$/g, '');\n\nconst baseDir = $env.MANUAL_INTAKE_DIR || $env.TEMP || $env.TMP || '/tmp';\nconst dir = path.join(baseDir, 'manual-intake');\nfs.mkdirSync(dir, { recursive: true });\n\nconst filePath = path.join(\n  dir,\n  `${safeBase || 'upload'}-${$execution.id}-${$itemIndex}.${ext || 'bin'}`\n);\n\nconst providedTitle = ($json.title || '').trim();\nconst documentTitle = providedTitle || safeBase || baseName || 'Manual Upload';\n\nreturn {\n  json: {\n    filePath,\n    fileName,\n    fileExt: ext || 'bin',\n    documentTitle,\n    binaryKey\n  }\n};"
      },
      "id": "save-upload",
      "name": "Prepare Uploaded File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        140
      ]
    },
    {
      "parameters": {
        "fileName": "={{ $json.filePath }}",
        "dataPropertyName": "={{ $json.binaryKey || 'file' }}"
      },
      "id": "write-binary-file",
      "name": "Write Binary File",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        1100,
        140
      ]
    },
    {
      "parameters": {
        "command": "={{ 'python ' + ($env.MANUAL_INTAKE_SCRIPT || 'scripts/extract_text.py') + ' --input \"' + $json.filePath + '\" --title \"' + $json.documentTitle + '\" --max-words 2500' }}"
      },
      "id": "extract-text",
      "name": "Extract Text (File)",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1320,
        140
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const item = $input.first().json;\nconst stdout = item.stdout || '';\nif (!stdout.trim()) {\n  throw new Error('No output from extract_text.py');\n}\n\nconst payload = JSON.parse(stdout);\nif (payload.error) {\n  throw new Error(payload.error);\n}\n\nconst docTitle = payload.document_title || 'Manual Upload';\nconst sections = payload.sections || [];\n\nreturn sections.map((section, index) => ({\n  json: {\n    title: section.title || docTitle || `Part ${index + 1}` ,\n    text: section.text || '',\n    documentTitle: docTitle,\n    order: index + 1\n  }\n}));"
      },
      "id": "parse-sections",
      "name": "Parse Extracted Sections",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1320,
        140
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const item = $input.first().json;\nconst rawText = (item.text || '').trim();\nconst docTitle = (item.title || 'Manual Input').trim();\nconst maxWords = 2500;\n\nif (!rawText) {\n  throw new Error('No text provided in request body');\n}\n\nconst chapterRe = /^(chapter|kapitola|book|part)\\s+([0-9ivxlcdm]+)(\\b.*)?$/i;\nconst lines = rawText.split(/\\r?\\n/).map((line) => line.trim());\n\nconst sections = [];\nlet currentTitle = docTitle;\nlet currentLines = [];\nlet sawHeading = false;\n\nfunction flush(title) {\n  const body = currentLines.filter(Boolean).join('\\n').trim();\n  if (body) {\n    sections.push({ title, text: body });\n  }\n  currentLines = [];\n}\n\nfor (const line of lines) {\n  if (!line) continue;\n  if (chapterRe.test(line)) {\n    if (currentLines.length) {\n      flush(sawHeading ? currentTitle : 'Intro');\n    }\n    currentTitle = line;\n    sawHeading = true;\n    continue;\n  }\n  currentLines.push(line);\n}\n\nif (currentLines.length) {\n  flush(currentTitle);\n}\n\nif (!sections.length) {\n  const words = rawText.split(/\\s+/).filter(Boolean);\n  for (let i = 0; i < words.length; i += maxWords) {\n    const chunk = words.slice(i, i + maxWords).join(' ');\n    sections.push({ title: `Part ${sections.length + 1}`, text: chunk });\n  }\n}\n\nreturn sections.map((section, index) => ({\n  json: {\n    title: section.title || docTitle || `Part ${index + 1}` ,\n    text: section.text || '',\n    documentTitle: docTitle,\n    order: index + 1\n  }\n}));"
      },
      "id": "split-text",
      "name": "Split Pasted Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        460
      ]
    },
    {
      "parameters": {
        "mode": "manual",
        "duplicateItem": false,
        "assignments": {
          "assignments": [
            {
              "id": "manual-source-url",
              "name": "source_url",
              "value": "={{ 'manual:' + ($json.documentTitle || $json.title || 'upload').toLowerCase().replace(/[^a-z0-9]+/g, '-') + ':' + $execution.id + ':' + $itemIndex }}",
              "type": "string"
            },
            {
              "id": "manual-source-website",
              "name": "source_website",
              "value": "manual",
              "type": "string"
            },
            {
              "id": "manual-title",
              "name": "title",
              "value": "={{ $json.title || $json.documentTitle || 'Manual Input' }}",
              "type": "string"
            },
            {
              "id": "manual-raw-html",
              "name": "raw_html",
              "value": "={{ $json.text }}",
              "type": "string"
            },
            {
              "id": "manual-content",
              "name": "content",
              "value": "={{ $json.text }}",
              "type": "string"
            }
          ]
        }
      },
      "id": "prepare-article",
      "name": "Prepare Article Fields",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1540,
        300
      ]
    },
    {
      "parameters": {
        "operation": "create",
        "tableId": "articles",
        "dataMode": "defineBelow",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "source_url",
              "fieldValue": "={{ $json.source_url }}"
            },
            {
              "fieldId": "source_website",
              "fieldValue": "={{ $json.source_website }}"
            },
            {
              "fieldId": "title",
              "fieldValue": "={{ $json.title }}"
            },
            {
              "fieldId": "raw_html",
              "fieldValue": "={{ $json.raw_html }}"
            },
            {
              "fieldId": "content",
              "fieldValue": "={{ $json.content }}"
            }
          ]
        }
      },
      "id": "supabase-insert-manual",
      "name": "Supabase Insert - Manual",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1760,
        300
      ],
      "continueOnFail": true,
      "credentials": {
        "supabaseApi": {
          "id": "woAUTvWByiJ9u8p2",
          "name": "Supabase account"
        }
      }
    }
  ],
  "connections": {
    "Manual Intake Webhook": {
      "main": [
        [
          {
            "node": "Detect Input Mode",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Input Mode": {
      "main": [
        [
          {
            "node": "Has File?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has File?": {
      "main": [
        [
          {
            "node": "Save Uploaded File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Split Pasted Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Uploaded File": {
      "main": [
        [
          {
            "node": "Write Binary File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Binary File": {
      "main": [
        [
          {
            "node": "Extract Text (File)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text (File)": {
      "main": [
        [
          {
            "node": "Parse Extracted Sections",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Extracted Sections": {
      "main": [
        [
          {
            "node": "Prepare Article Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Pasted Text": {
      "main": [
        [
          {
            "node": "Prepare Article Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Article Fields": {
      "main": [
        [
          {
            "node": "Supabase Insert - Manual",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-11-06T00:00:00.000Z",
  "versionId": "1"
}
